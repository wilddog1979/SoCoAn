<?xml version="1.0" encoding="UTF-8"?>
<Language xmlns="http://eaSTars.com/SoCoAn/lang">
	
	<LiteralType id="Digit0" literal="0"/>
	<LiteralType id="Digit1" literal="1"/>
	<LiteralType id="Digit2" literal="2"/>
	<LiteralType id="Digit3" literal="3"/>
	<LiteralType id="Digit4" literal="4"/>
	<LiteralType id="Digit5" literal="5"/>
	<LiteralType id="Digit6" literal="6"/>
	<LiteralType id="Digit7" literal="7"/>
	<LiteralType id="Digit8" literal="8"/>
	<LiteralType id="Digit9" literal="9"/>
	<LiteralType id="Digita" literal="a"/>
	<LiteralType id="Digitb" literal="b"/>
	<LiteralType id="Digitc" literal="c"/>
	<LiteralType id="Digitd" literal="d"/>
	<LiteralType id="Digite" literal="e"/>
	<LiteralType id="Digitf" literal="f"/>
	<LiteralType id="DigitA" literal="A"/>
	<LiteralType id="DigitB" literal="B"/>
	<LiteralType id="DigitC" literal="C"/>
	<LiteralType id="DigitD" literal="D"/>
	<LiteralType id="DigitE" literal="E"/>
	<LiteralType id="DigitF" literal="F"/>
	
	<LiteralType id="SP" literal=" "/>
	<LiteralType id="HT" literal="\t"/>
	<LiteralType id="FF" literal="\f"/>
	<LiteralType id="LF" literal="\n"/>
	<LiteralType id="CR" literal="\r"/>
	<LiteralType id="BS" literal="\b"/>
	
	<ComplexType id="BinaryDigit" processor="aggregating">
		<StartNode sequence="Any">
			<Node type="Digit0"/>
			<Node type="Digit1"/>
		</StartNode>
	</ComplexType>
	
	<ComplexType id="ZeroToThree" processor="aggregating">
		<StartNode sequence="Any">
			<Node type="Digit0"/>
			<Node type="Digit1"/>
			<Node type="Digit2"/>
			<Node type="Digit3"/>
		</StartNode>
	</ComplexType>
	
	<ComplexType id="OctalDigit" processor="aggregating">
		<StartNode sequence="Any">
			<Node type="Digit0"/>
			<Node type="Digit1"/>
			<Node type="Digit2"/>
			<Node type="Digit3"/>
			<Node type="Digit4"/>
			<Node type="Digit5"/>
			<Node type="Digit6"/>
			<Node type="Digit7"/>
		</StartNode>
	</ComplexType>
	
	<ComplexType id="NonZeroDigit" processor="aggregating">
		<StartNode sequence="Any">
			<Node type="Digit0"/>
			<Node type="Digit1"/>
			<Node type="Digit2"/>
			<Node type="Digit3"/>
			<Node type="Digit4"/>
			<Node type="Digit5"/>
			<Node type="Digit6"/>
			<Node type="Digit7"/>
			<Node type="Digit8"/>
			<Node type="Digit9"/>
		</StartNode>
	</ComplexType>
	
	<ComplexType id="Digit" processor="aggregating">
		<StartNode sequence="Any">
			<Node type="Digit0"/>
			<Node type="NonZeroDigit"/>
		</StartNode>
	</ComplexType>
	
	<ComplexType id="HexDigit" processor="aggregating">
		<StartNode sequence="Any">
			<Node type="Digit0"/>
			<Node type="Digit1"/>
			<Node type="Digit2"/>
			<Node type="Digit3"/>
			<Node type="Digit4"/>
			<Node type="Digit5"/>
			<Node type="Digit6"/>
			<Node type="Digit7"/>
			<Node type="Digit8"/>
			<Node type="Digit9"/>
			<Node type="Digita"/>
			<Node type="Digitb"/>
			<Node type="Digitc"/>
			<Node type="Digitd"/>
			<Node type="Digite"/>
			<Node type="Digitf"/>
			<Node type="DigitA"/>
			<Node type="DigitB"/>
			<Node type="DigitC"/>
			<Node type="DigitD"/>
			<Node type="DigitE"/>
			<Node type="DigitF"/>
		</StartNode>
	</ComplexType>
	
	<LiteralType id="Backslash" literal="\"/>
	
	<!-- 3.3 Unicode Escapes -->
	
	<LiteralType id="UnicodeEscapeu" literal="u"/>

	<ComplexType id="UnicodeMarker" processor="aggregating">
		<StartNode sequence="Order">
			<Node type="UnicodeEscapeu"/>
			<Node type="UnicodeEscapeu" occurrence="ZeroOrMore"/>
		</StartNode>
	</ComplexType>

	<ComplexType id="UnicodeEscape" processor="aggregating">
		<StartNode sequence="Order">
			<Node type="Backslash" sequence="Order"/>
			<Node type="UnicodeMarker"/>
			<Node type="HexDigit"/>
			<Node type="HexDigit"/>
			<Node type="HexDigit"/>
			<Node type="HexDigit"/>
		</StartNode>
	</ComplexType>
	
	<CustomType id="RawInputCharacter" recognizer="RawInputCharacter"/>

	<ComplexType id="UnicodeInputCharacter" processor="aggregating">
		<StartNode sequence="Any">
			<Node type="UnicodeEscape"/>
			<Node type="RawInputCharacter"/>
		</StartNode>
	</ComplexType>
	
	<!-- 3.4 Line Terminators -->

	<ComplexType id="LineTerminator" processor="aggregating">
		<StartNode sequence="Any">
			<GroupNode sequence="Order">
				<Node type="CR" occurrence="ZeroOrOne"/>
				<Node type="LF"/>
			</GroupNode>
			<Node type="CR"/>
		</StartNode>
	</ComplexType>

	<ComplexType id="InputCharacter" processor="aggregating" checker="InputCharacterCheck">
		<StartNode sequence="Order">
			<Node type="UnicodeInputCharacter"/>
		</StartNode>
	</ComplexType>
	
	<!-- 3.6 White Space -->

	<ComplexType id="WhiteSpace" processor="aggregating" multiple="true">
		<StartNode sequence="Any">
			<Node type="SP"/>
			<Node type="HT"/>
			<Node type="FF"/>
			<Node type="LineTerminator"/>
		</StartNode>
	</ComplexType>
	
	<!-- 3.7 Comments -->
	
	<LiteralType id="JavaDocStart" literal="/**"/>
	<LiteralType id="TraditionalCommentStart" literal="/*"/>
	
	<TerminatedType id="TraditionalCommentContent">
		<Terminator>*/</Terminator>
	</TerminatedType>
	
	<LiteralType id="EndOfLineCommentStart" literal="//"/>
	
	<TerminatedType id="EndOfLineCommentContent">
		<Terminator>\r\n</Terminator>
		<Terminator>\n</Terminator>
	</TerminatedType>
	
	<ComplexType id="Comment" processor="comment">
		<StartNode sequence="Order">
			<Node id="JavaDoc" type="JavaDocStart"/>
			<Node type="TraditionalCommentContent"/>
		</StartNode>
		
		<StartNode sequence="Order">
			<Node id="TraditionalComment" type="TraditionalCommentStart"/>
			<Node type="TraditionalCommentContent"/>
		</StartNode>
		
		<StartNode sequence="Order">
			<Node id="EndOfLineComment" type="EndOfLineCommentStart"/>
			<Node type="EndOfLineCommentContent"/>
		</StartNode>
	</ComplexType>
	
	<!-- 3.8 Identifiers -->
	
	<CustomType id="JavaLetter" recognizer="JavaLetter"/>
	
	<CustomType id="JavaLetterOrDigit" recognizer="JavaLetterOrDigit"/>
	
	<ComplexType id="Identifier" processor="aggregating" checker="IdentifierCheck">
		<StartNode sequence="Order">
			<Node type="JavaLetter"/>
			<Node type="JavaLetterOrDigit" occurrence="ZeroOrMore"/>
		</StartNode>
	</ComplexType>
	
	<!-- 3.9 Keywords -->
	
	<KeywordType id="keyword_abstract" literal="abstract"/>
	<KeywordType id="keyword_assert" literal="assert"/>
	<KeywordType id="keyword_boolean" literal="boolean"/>
	<KeywordType id="keyword_break" literal="break"/>
	<KeywordType id="keyword_byte" literal="byte"/>
	<KeywordType id="keyword_case" literal="case"/>
	<KeywordType id="keyword_catch" literal="catch"/>
	<KeywordType id="keyword_char" literal="char"/>
	<KeywordType id="keyword_class" literal="class"/>
	<KeywordType id="keyword_const" literal="const"/>
	<KeywordType id="keyword_continue" literal="continue"/>
	<KeywordType id="keyword_default" literal="default"/>
	<KeywordType id="keyword_do" literal="do"/>
	<KeywordType id="keyword_double" literal="double"/>
	<KeywordType id="keyword_else" literal="else"/>
	<KeywordType id="keyword_enum" literal="enum"/>
	<KeywordType id="keyword_extends" literal="extends"/>
	<KeywordType id="keyword_final" literal="final"/>
	<KeywordType id="keyword_finally" literal="finally"/>
	<KeywordType id="keyword_float" literal="float"/>
	<KeywordType id="keyword_for" literal="for"/>
	<KeywordType id="keyword_if" literal="if"/>
	<KeywordType id="keyword_goto" literal="goto"/>
	<KeywordType id="keyword_implements" literal="implements"/>
	<KeywordType id="keyword_import" literal="import"/>
	<KeywordType id="keyword_instanceof" literal="instanceof"/>
	<KeywordType id="keyword_int" literal="int"/>
	<KeywordType id="keyword_interface" literal="interface"/>
	<KeywordType id="keyword_long" literal="long"/>
	<KeywordType id="keyword_native" literal="native"/>
	<KeywordType id="keyword_new" literal="new"/>
	<KeywordType id="keyword_package" literal="package"/>
	<KeywordType id="keyword_private" literal="private"/>
	<KeywordType id="keyword_protected" literal="protected"/>
	<KeywordType id="keyword_public" literal="public"/>
	<KeywordType id="keyword_return" literal="return"/>
	<KeywordType id="keyword_short" literal="short"/>
	<KeywordType id="keyword_static" literal="static"/>
	<KeywordType id="keyword_strictfp" literal="strictfp"/>
	<KeywordType id="keyword_super" literal="super"/>
	<KeywordType id="keyword_switch" literal="switch"/>
	<KeywordType id="keyword_synchronized" literal="synchronized"/>
	<KeywordType id="keyword_this" literal="this"/>
	<KeywordType id="keyword_throw" literal="throw"/>
	<KeywordType id="keyword_throws" literal="throws"/>
	<KeywordType id="keyword_transient" literal="transient"/>
	<KeywordType id="keyword_try" literal="try"/>
	<KeywordType id="keyword_void" literal="void"/>
	<KeywordType id="keyword_volatile" literal="volatile"/>
	<KeywordType id="keyword_while" literal="while"/>
	
	<ComplexType id="Keyword" processor="aggregating">
		<StartNode sequence="Any">
			<Node type="keyword_abstract"/>
			<Node type="keyword_assert"/>
			<Node type="keyword_boolean"/>
			<Node type="keyword_break"/>
			<Node type="keyword_byte"/>
			<Node type="keyword_case"/>
			<Node type="keyword_catch"/>
			<Node type="keyword_char"/>
			<Node type="keyword_class"/>
			<Node type="keyword_const"/>
			<Node type="keyword_continue"/>
			<Node type="keyword_default"/>
			<Node type="keyword_do"/>
			<Node type="keyword_double"/>
			<Node type="keyword_else"/>
			<Node type="keyword_enum"/>
			<Node type="keyword_extends"/>
			<Node type="keyword_final"/>
			<Node type="keyword_finally"/>
			<Node type="keyword_float"/>
			<Node type="keyword_for"/>
			<Node type="keyword_if"/>
			<Node type="keyword_goto"/>
			<Node type="keyword_implements"/>
			<Node type="keyword_import"/>
			<Node type="keyword_instanceof"/>
			<Node type="keyword_int"/>
			<Node type="keyword_interface"/>
			<Node type="keyword_long"/>
			<Node type="keyword_native"/>
			<Node type="keyword_new"/>
			<Node type="keyword_package"/>
			<Node type="keyword_private"/>
			<Node type="keyword_protected"/>
			<Node type="keyword_public"/>
			<Node type="keyword_return"/>
			<Node type="keyword_short"/>
			<Node type="keyword_static"/>
			<Node type="keyword_strictfp"/>
			<Node type="keyword_super"/>
			<Node type="keyword_switch"/>
			<Node type="keyword_synchronized"/>
			<Node type="keyword_this"/>
			<Node type="keyword_throw"/>
			<Node type="keyword_throws"/>
			<Node type="keyword_transient"/>
			<Node type="keyword_try"/>
			<Node type="keyword_void"/>
			<Node type="keyword_volatile"/>
			<Node type="keyword_while"/>
		</StartNode>
	</ComplexType>
	
	<!-- 3.10 Literals -->
	
	<ComplexType id="Literal" processor="aggregating">
		<StartNode sequence="Any">
			<Node type="IntegerLiteral"/>
			<Node type="FloatingPointLiteral"/>
			<Node type="BooleanLiteral"/>
			<Node type="CharacterLiteral"/>
			<Node type="StringLiteral"/>
			<Node type="NullLiteral"/>
		</StartNode>
	</ComplexType>
	
	<!-- 3.10.1 Integer Literals -->
	
	<ComplexType id="IntegerLiteral" processor="aggregating">
		<StartNode sequence="Any">
			<Node type="HexIntegerLiteral"/>
			<Node type="BinaryIntegerLiteral"/>
			<Node type="OctalIntegerLiteral"/>
			<Node type="DecimalIntegerLiteral"/>
		</StartNode>
	</ComplexType>
	
	<ComplexType id="DecimalIntegerLiteral" processor="aggregating">
		<StartNode sequence="Order">
			<Node type="DecimalNumeral"/>
			<Node type="IntegerTypeSuffix" occurrence="ZeroOrOne"/>
		</StartNode>
	</ComplexType>
	
	<ComplexType id="HexIntegerLiteral" processor="aggregating">
		<StartNode sequence="Order">
			<Node type="HexNumeral"/>
			<Node type="IntegerTypeSuffix" occurrence="ZeroOrOne"/>
		</StartNode>
	</ComplexType>
	
	<ComplexType id="OctalIntegerLiteral" processor="aggregating">
		<StartNode sequence="Order">
			<Node type="OctalNumeral"/>
			<Node type="IntegerTypeSuffix" occurrence="ZeroOrOne"/>
		</StartNode>
	</ComplexType>
	
	<ComplexType id="BinaryIntegerLiteral" processor="aggregating">
		<StartNode sequence="Order">
			<Node type="BinaryNumeral"/>
			<Node type="IntegerTypeSuffix" occurrence="ZeroOrOne"/>
		</StartNode>
	</ComplexType>
	
	<LiteralType id="Suffixl" literal="l"/>
	<LiteralType id="SuffixL" literal="L"/>
	
	<ComplexType id="IntegerTypeSuffix" processor="aggregating">
		<StartNode sequence="Any">
			<Node type="Suffixl"/>
			<Node type="SuffixL"/>
		</StartNode>
	</ComplexType>
	
	<LiteralType id="Underscore" literal="_"/>
	
	<ComplexType id="DecimalNumeral" processor="aggregating">
		<StartNode sequence="Any">
			<Node type="Digit0"/>
			<GroupNode sequence="Order">
				<Node type="NonZeroDigit"/>
				<GroupNode sequence="Any">
					<Node type="Digits" occurrence="ZeroOrOne"/>
					<GroupNode sequence="Order">
						<Node type="Underscore"/>
						<Node type="Digits"/>
					</GroupNode>
				</GroupNode>
			</GroupNode>
		</StartNode>
	</ComplexType>
	
	<!-- this definition must be fixed because it allows underscore on the end of the number which is not valid -->
	<ComplexType id="Digits" processor="aggregating">
		<StartNode sequence="Order">
			<Node type="Digit"/>
			<Node type="DigitsAndUnderscores" occurrence="ZeroOrOne"/>
		</StartNode>
	</ComplexType>
	
	<ComplexType id="DigitsAndUnderscores" processor="aggregating">
		<StartNode sequence="Order">
			<Node type="DigitOrUnderscore"/>
			<Node type="DigitOrUnderscore" occurrence="ZeroOrMore"/>
		</StartNode>
	</ComplexType>
	
	<ComplexType id="DigitOrUnderscore" processor="aggregating">
		<StartNode sequence="Any">
			<Node type="Digit"/>
			<Node type="Underscore" occurrence="ZeroOrMore"/>
		</StartNode>
	</ComplexType>
	
	<LiteralType id="Prefix0x" literal="0x"/>
	<LiteralType id="Prefix0X" literal="0X"/>
	
	<ComplexType id="HexNumeral" processor="aggregating">
		<StartNode sequence="Order">
			<GroupNode sequence="Any">
				<Node type="Prefix0x"/>
				<Node type="Prefix0X"/>
			</GroupNode>
			<Node type="HexDigits"/>
		</StartNode>
	</ComplexType>
	
	<!-- this definition must be fixed because it allows underscore on the end of the number which is not valid -->
	<ComplexType id="HexDigits" processor="aggregating">
		<StartNode sequence="Order">
			<Node type="HexDigit"/>
			<Node type="HexDigitsAndUnderscores"  occurrence="ZeroOrOne"/>
		</StartNode>
	</ComplexType>
	
	<ComplexType id="HexDigitsAndUnderscores" processor="aggregating">
		<StartNode sequence="Order">
			<Node type="HexDigitOrUnderscore"/>
			<Node type="HexDigitOrUnderscore" occurrence="ZeroOrMore"/>
		</StartNode>
	</ComplexType>
	
	<ComplexType id="HexDigitOrUnderscore" processor="aggregating">
		<StartNode sequence="Any">
			<Node type="HexDigit"/>
			<Node type="Underscore" occurrence="ZeroOrMore"/>
		</StartNode>
	</ComplexType>
	
	<ComplexType id="OctalNumeral" processor="aggregating">
		<StartNode sequence="Order">
			<Node type="Digit0"/>
			<Node type="Underscore" occurrence="ZeroOrMore"/>
			<Node type="OctalDigits"/>
		</StartNode>
	</ComplexType>
	
	<!-- this definition must be fixed because it allows underscore on the end of the number which is not valid -->
	<ComplexType id="OctalDigits" processor="aggregating">
		<StartNode  sequence="Order">
			<Node type="OctalDigit"/>
			<Node type="OctalDigitsAndUnderscores" occurrence="ZeroOrOne"/>
		</StartNode>
	</ComplexType>
	
	<ComplexType id="OctalDigitsAndUnderscores" processor="aggregating">
		<StartNode sequence="Order">
			<Node type="OctalDigitOrUnderscore"/>
			<Node type="OctalDigitOrUnderscore" occurrence="ZeroOrMore"/>
		</StartNode>
	</ComplexType>
	
	<ComplexType id="OctalDigitOrUnderscore" processor="aggregating">
		<StartNode sequence="Any">
			<Node type="OctalDigit"/>
			<Node type="Underscore"/>
		</StartNode>
	</ComplexType>

	<LiteralType id="Prefix0b" literal="0b"/>
	<LiteralType id="Prefix0B" literal="0B"/>

	<ComplexType id="BinaryNumeral" processor="aggregating">
		<StartNode sequence="Order">
			<GroupNode sequence="Any">
				<Node type="Prefix0b"/>
				<Node type="Prefix0B"/>
			</GroupNode>
			<Node type="BinaryDigits"/>
		</StartNode>
	</ComplexType>
	
	<!-- this definition must be fixed because it allows underscore on the end of the number which is not valid -->
	<ComplexType id="BinaryDigits" processor="aggregating">
		<StartNode sequence="Order">
			<Node type="BinaryDigit"/>
			<Node type="BinaryDigitsAndUnderscores" occurrence="ZeroOrOne"/>
		</StartNode>
	</ComplexType>
	
	<ComplexType id="BinaryDigitsAndUnderscores" processor="aggregating">
		<StartNode sequence="Order">
			<Node type="BinaryDigitOrUnderscore"/>
			<Node type="BinaryDigitOrUnderscore" occurrence="ZeroOrMore"/>
		</StartNode>
	</ComplexType>
	
	<ComplexType id="BinaryDigitOrUnderscore" processor="aggregating">
		<StartNode sequence="Any">
			<Node type="BinaryDigit"/>
			<Node type="Underscore"/>
		</StartNode>
	</ComplexType>
	
	<!-- 3.10.2 Floating-Point Literals -->
	
	<ComplexType id="FloatingPointLiteral" processor="aggregating">
		<StartNode sequence="Any">
			<Node type="DecimalFloatingPointLiteral"/>
			<Node type="HexadecimalFloatingPointLiteral"/>
		</StartNode>
	</ComplexType>
	
	<LiteralType id="DecimalSeparator" literal="."/>
	
	<ComplexType id="DecimalFloatingPointLiteral" processor="aggregating">
		<StartNode sequence="Order">
			<Node type="Digits"/>
			<Node type="DecimalSeparator"/>
			<Node type="Digits" occurrence="ZeroOrOne"/>
			<Node type="ExponentPart" occurrence="ZeroOrOne"/>
			<Node type="FloatTypeSuffix" occurrence="ZeroOrOne"/>
		</StartNode>
		<StartNode sequence="Order">
			<Node type="DecimalSeparator"/>
			<Node type="Digits"/>
			<Node type="ExponentPart" occurrence="ZeroOrOne"/>
			<Node type="FloatTypeSuffix" occurrence="ZeroOrOne"/>
		</StartNode>
		<StartNode sequence="Order">
			<Node type="Digits"/>
			<Node type="ExponentPart"/>
			<Node type="FloatTypeSuffix" occurrence="ZeroOrOne"/>
		</StartNode>
		<StartNode sequence="Order">
			<Node type="Digits"/>
			<Node type="ExponentPart" occurrence="ZeroOrOne"/>
			<Node type="FloatTypeSuffix"/>
		</StartNode>
	</ComplexType>
	
	<ComplexType id="ExponentPart" processor="aggregating">
		<StartNode sequence="Order">
			<Node type="ExponentIndicator"/>
			<Node type="SignedInteger"/>
		</StartNode>
	</ComplexType>
	
	<LiteralType id="Exponente" literal="e"/>
	<LiteralType id="ExponentE" literal="E"/>
	
	<ComplexType id="ExponentIndicator" processor="aggregating">
		<StartNode sequence="Any">
			<Node type="Exponente"/>
			<Node type="ExponentE"/>
		</StartNode>
	</ComplexType>
	
	<ComplexType id="SignedInteger" processor="aggregating">
		<StartNode sequence="Order">
			<Node type="Sign" occurrence="ZeroOrOne"/>
			<Node type="Digits"/>
		</StartNode>
	</ComplexType>
	
	<LiteralType id="Sign+" literal="+"/>
	<LiteralType id="Sign-" literal="-"/>
	
	<ComplexType id="Sign" processor="aggregating">
		<StartNode sequence="Any">
			<Node type="Sign+"/>
			<Node type="Sign-"/>
		</StartNode>
	</ComplexType>
	
	<LiteralType id="FloatTypef" literal="f"/>
	<LiteralType id="FloatTypeF" literal="F"/>
	<LiteralType id="FloatTyped" literal="d"/>
	<LiteralType id="FloatTypeD" literal="D"/>
	
	<ComplexType id="FloatTypeSuffix" processor="aggregating">
		<StartNode sequence="Any">
			<Node type="FloatTypef"/>
			<Node type="FloatTypeF"/>
			<Node type="FloatTyped"/>
			<Node type="FloatTypeD"/>
		</StartNode>
	</ComplexType>
	
	<ComplexType id="HexadecimalFloatingPointLiteral" processor="aggregating">
		<StartNode sequence="Order">
			<Node type="HexSignificant"/>
			<Node type="BinaryExponent"/>
			<Node type="FloatTypeSuffix" occurrence="ZeroOrOne"/>
		</StartNode>
	</ComplexType>
	
	<ComplexType id="HexSignificant" processor="aggregating">
		<StartNode sequence="Order">
			<GroupNode sequence="Any">
				<Node type="Prefix0x"/>
				<Node type="Prefix0X"/>
			</GroupNode>
			<Node type="HexDigits" occurrence="ZeroOrOne"/>
			<Node type="DecimalSeparator"/>
			<Node type="HexDigits"/>
		</StartNode>
		<StartNode sequence="Order">
			<Node type="HexNumeral"/>
			<Node type="DecimalSeparator" occurrence="ZeroOrOne"/>
		</StartNode>
	</ComplexType>
	
	<ComplexType id="BinaryExponent" processor="aggregating">
		<StartNode sequence="Order">
			<Node type="BinaryExponentIndicator"/>
			<Node type="SignedInteger"/>
		</StartNode>
	</ComplexType>
	
	<LiteralType id="BinaryExpp" literal="p"/>
	<LiteralType id="BinaryExpP" literal="P"/>
	
	<ComplexType id="BinaryExponentIndicator" processor="aggregating">
		<StartNode sequence="Any">
			<Node type="BinaryExpp"/>
			<Node type="BinaryExpP"/>
		</StartNode>
	</ComplexType>
	
	<!-- 3.10.3 Boolean Literals -->
	
	<LiteralType id="True" literal="true"/>
	<LiteralType id="False" literal="false"/>
	
	<ComplexType id="BooleanLiteral" processor="aggregating">
		<StartNode sequence="Any">
			<Node type="True"/>
			<Node type="False"/>
		</StartNode>
	</ComplexType>
	
	<!-- 3.10.4 Character Literals -->
	
	<LiteralType id="SingleQuote" literal="'"/>
	
	<ComplexType id="CharacterLiteral" processor="aggregating">
		<StartNode sequence="Order">
			<Node type="SingleQuote"/>
			<Node type="SingleCharacter"/>
			<Node type="SingleQuote"/>
		</StartNode>
		<StartNode sequence="Order">
			<Node type="SingleQuote"/>
			<Node type="EscapeSequence"/>
			<Node type="SingleQuote"/>
		</StartNode>
	</ComplexType>
	
	<ComplexType id="SingleCharacter" processor="aggregating" checker="SingleCharacterCheck">
		<StartNode sequence="Order">
			<Node type="InputCharacter"/>
		</StartNode>
	</ComplexType>
	
	<!-- 3.10.5 String Literals -->
	
	<LiteralType id="DoubleQuote" literal="&quot;"/>
	
	<ComplexType id="StringLiteral" processor="aggregating">
		<StartNode sequence="Order">
			<Node type="DoubleQuote"/>
			<Node type="StringCharacter" occurrence="ZeroOrMore"/>
			<Node type="DoubleQuote"/>
		</StartNode>
	</ComplexType>
	
	<ComplexType id="StringCharacter" processor="aggregating" checker="StringCharactersCheck">
		<StartNode sequence="Order">
			<Node type="InputCharacter"/>
		</StartNode>
	</ComplexType>
	
	<!-- 3.10.6 Escape Sequences for Character and String Literals -->
	
	<LiteralType id="Escapeb" literal="b"/>
	<LiteralType id="Escapet" literal="t"/>
	<LiteralType id="Escapen" literal="n"/>
	<LiteralType id="Escapef" literal="f"/>
	<LiteralType id="Escaper" literal="r"/>
	
	<ComplexType id="EscapeSequence" processor="aggregating">
		<StartNode sequence="Any">
			<GroupNode sequence="Order">
				<Node type="Backslash"/>
				<GroupNode sequence="Any">
					<Node type="Escapeb"/>
					<Node type="Escapet"/>
					<Node type="Escapen"/>
					<Node type="Escapef"/>
					<Node type="Escaper"/>
					<Node type="DoubleQuote"/>
					<Node type="SingleQuote"/>
					<Node type="Backslash"/>
				</GroupNode>
			</GroupNode>
			<Node type="OctalEscape"/>
		</StartNode>
	</ComplexType>
	
	<ComplexType id="OctalEscape" processor="aggregating">
		<StartNode sequence="Order">
			<Node type="Backslash"/>
			<Node type="ZeroToThree"/>
			<Node type="OctalDigit"/>
			<Node type="OctalDigit"/>
		</StartNode>
		<StartNode sequence="Order">
			<Node type="Backslash"/>
			<Node type="OctalDigit"/>
			<Node type="OctalDigit"/>
		</StartNode>
		<StartNode sequence="Order">
			<Node type="Backslash"/>
			<Node type="OctalDigit"/>
		</StartNode>
	</ComplexType>
	
	<!-- 3.10.7 The Null Literal -->
	
	<LiteralType id="NullLiteral" literal="null"/>
	
	<!-- 3.11 Separators -->
	
	<LiteralType id="bracket_open" literal="("/>
	<LiteralType id="bracket_close" literal=")"/>
	<LiteralType id="curlybracket_open" literal="{"/>
	<LiteralType id="curlybracket_close" literal="}"/>
	<LiteralType id="squarebracket_open" literal="["/>
	<LiteralType id="squarebracket_close" literal="]"/>
	<LiteralType id="semicolon" literal=";"/>
	<LiteralType id="comma" literal=","/>
	<LiteralType id="dot" literal="."/>
	<LiteralType id="tripledot" literal="..."/>
	<LiteralType id="at" literal="@"/>
	<LiteralType id="doubecolon" literal="::"/>
	
	<ComplexType id="Separators" processor="aggregating">
		<StartNode sequence="Any">
			<Node type="bracket_open"/>
			<Node type="bracket_close"/>
			<Node type="curlybracket_open"/>
			<Node type="curlybracket_close"/>
			<Node type="squarebracket_open"/>
			<Node type="squarebracket_close"/>
			<Node type="semicolon"/>
			<Node type="comma"/>
			<Node type="dot"/>
			<Node type="tripledot"/>
			<Node type="at"/>
			<Node type="doubecolon"/>
		</StartNode>
	</ComplexType>
	
	<!-- 3.12 Operators -->
	
	<LiteralType id="equal" literal="="/>
	<LiteralType id="greaterthan" literal="&gt;"/>
	<LiteralType id="lowerthan" literal="&lt;"/>
	<LiteralType id="exclamationmark" literal="!"/>
	<LiteralType id="tilde" literal="~"/>
	<LiteralType id="questionmark" literal="?"/>
	<LiteralType id="colon" literal=":"/>
	<LiteralType id="arrowtoken" literal="-&gt;"/>
	
	<LiteralType id="doubleequal" literal="=="/>
	<LiteralType id="greaterthanorequal" literal="&gt;="/>
	<LiteralType id="lowerthanorequal" literal="&lt;="/>
	<LiteralType id="notequal" literal="!="/>
	<LiteralType id="doubleand" literal="&amp;&amp;"/>
	<LiteralType id="doubleor" literal="||"/>
	<LiteralType id="doubleplus" literal="++"/>
	<LiteralType id="doubleminus" literal="--"/>
	
	<LiteralType id="plus" literal="+"/>
	<LiteralType id="minus" literal="-"/>
	<LiteralType id="multiply" literal="*"/>
	<LiteralType id="divide" literal="/"/>
	<LiteralType id="and" literal="&amp;"/>
	<LiteralType id="or" literal="|"/>
	<LiteralType id="xor" literal="^"/>
	<LiteralType id="remainder" literal="%"/>
	<LiteralType id="shiftleft" literal="&lt;&lt;"/>
	<LiteralType id="shiftright" literal="&gt;&gt;"/>
	<LiteralType id="zerofillshiftright" literal="&gt;&gt;&gt;"/>
	
	<LiteralType id="plusequal" literal="+="/>
	<LiteralType id="minusequal" literal="-="/>
	<LiteralType id="multiplyequal" literal="*="/>
	<LiteralType id="divideequal" literal="/="/>
	<LiteralType id="andequal" literal="&amp;="/>
	<LiteralType id="orequal" literal="|="/>
	<LiteralType id="xorequal" literal="^="/>
	<LiteralType id="remainderequal" literal="%="/>
	<LiteralType id="shiftleftequal" literal="&lt;&lt;="/>
	<LiteralType id="shiftrightequal" literal="&gt;&gt;="/>
	<LiteralType id="zerofillshiftrightequal" literal="&gt;&gt;&gt;="/>
	
	<ComplexType id="Operator" processor="aggregating">
		<StartNode sequence="Any">
			<Node type="equal"/>
			<Node type="greaterthan"/>
			<Node type="lowerthan"/>
			<Node type="exclamationmark"/>
			<Node type="tilde"/>
			<Node type="questionmark"/>
			<Node type="colon"/>
			<Node type="arrowtoken"/>
			
			<Node type="doubleequal"/>
			<Node type="greaterthanorequal"/>
			<Node type="lowerthanorequal"/>
			<Node type="notequal"/>
			<Node type="doubleand"/>
			<Node type="doubleor"/>
			<Node type="doubleplus"/>
			<Node type="doubleminus"/>
			
			<Node type="plus"/>
			<Node type="minus"/>
			<Node type="multiply"/>
			<Node type="divide"/>
			<Node type="and"/>
			<Node type="or"/>
			<Node type="xor"/>
			<Node type="remainder"/>
			<Node type="shiftleft"/>
			<Node type="shiftright"/>
			<Node type="zerofillshiftright"/>
			
			<Node type="plusequal"/>
			<Node type="minusequal"/>
			<Node type="multiplyequal"/>
			<Node type="divideequal"/>
			<Node type="andequal"/>
			<Node type="orequal"/>
			<Node type="xorequal"/>
			<Node type="remainderequal"/>
			<Node type="shiftleftequal"/>
			<Node type="shiftrightequal"/>
			<Node type="zerofillshiftrightequal"/>
		</StartNode>
	</ComplexType>
	
</Language>
